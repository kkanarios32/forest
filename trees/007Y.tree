
\import{base-macros}
\author{kellenkanarios}
\date{2025-07-01T10:43:22Z}
\title{[[007U]] (3/66): [TPE](arpaci2018operating) Process Interlude}
\put\transclude/numbered{false}
\p{This was a very short chapter just introducing the actual API for some very important system calls. Namely}
\section{\code{fork()}}{
  \p{
The \em{fork} system call allows a program to duplicate itself in a new process from the current instruction. This is quite literally a duplication which entails giving the child its own
\ol{
  \li{Address space}
  \li{Registers}
  \li{Program counter}
}
  }
\p{
A fork is invoked in the parent process like
  \pre\verb<<<|
  int main()
    int rc = fork();
    if (rc < 0) 
      printf("error with fork");
    else if (rc == 0)
      printf("in child");
    else
      printf("in parent");
  <<<
}
\p{
Importantly, you identify whether you are in the child or the parent via the return value of \code{rc} (0 for child), (PID of child for parent).
}
\remark{
Which process is run first (the parent or the child) is non-deterministic and depends on the CPU scheduling algorithm.
}
}
\section{\code{wait()}}{
  \p{
  Due to the remark, we need some way to enforce ordering among parent and child. This is the motivation for the \em{wait} system call. Namely, when the parent calls \code{wait()} it tells the CPU not to schedule it until the child completes. 
  }
  \question{
    From the previous [section](007V), we saw the data structure for a process included the state. I assume \code{wait()} is implemented by adjusting the process state in the PCB somehow?
  }
  \answer{
    Doing a bit more research, it seems this is on the right track. Additionally, when a child completes it enters the \code{ZOMBIE} state, where it stores all the relevant information of the process, so that the parent process can then use this information. How this is actually coordinated seems to involve \em{signals} and \em{wait_entries} that essentially track all the children of a parent. The OS can then get a signal of completion from a child and find the corresponding parent?
  }
}
\section{\code{exec()}}{
\p{While \code{fork()} is useful in the sense that it allows us to spawn new processes from a parent process, it is still limited in that it can only execute instructions following the line of the \code{fork()} call in the parent process.}
\p{In practice, we do not want to have to compile massive C projects that contain all the necessary files for every possible binary we may want to run. To get around this, we can use the \code{exec()} system call. \code{exec()} allows us to transform a process into the desired executable. What this entails:
\ol{
  \li{Loading the code and static data for the executable and overwriting the current coad and static data.}
  \li{Re-initializing stack and heap memory.}
  \li{Running the program, where the arguments passed to \code{exec()} are treated as \code{argv} for the program.}
}
For a parent process to invoke \code{ls}, they could do something like
  \pre\verb<<<|
  int main()
    int rc = fork();
    if (rc < 0) 
      printf("error with fork");
    else if (rc == 0)
      printf("in child");
      exec(ls);
    else
      printf("in parent");
  <<<
  This spawns a child process and overwrites it with the \code{ls} executable.
}
}
\example{
Combining \code{fork()} and \code{exec()} is where the true power lies. In particular, with this combination you can practically implement an entire shell. Below is some (hybrid) pseudocode.
\pre\verb<<<|
int main()
  while (true) {
    command = getcommand();
    int rc = fork();
    if (rc < 0) 
      printf("error with fork");
    else if (rc == 0)
      exec(command);
    else
      int rc = wait(NULL);
  }
<<<
You can also implement redirection by opening a file prior to calling \code{exec()} i.e.
\pre\verb<<<|
int main()
  while (true) {
    command = getcommand();
    int rc = fork();
    if (rc < 0) 
      printf("error with fork");
    else if (rc == 0)
      close(STD_OUT_FILENO);
      open(output.txt);
      exec(command);
    else
      int rc = wait(NULL);
  }
<<<
}
\section{Signals}{
\p{They briefly mention \em{signals}: what I expect to be an important topic in the future. Namely, you can send a signall to a process via \code{kill()} and the recipient program can "catch" this signal via the system call \code{signal()}.
}
\p{This naturally leads to the introduction of a \em{user}. The \em{user} determines which processes they are allowed to signal, where the \em{superuser} can arbitrarily signal all processes.}
}

\section{Coding Exercise}{
TODO (Saturday / Sunday)
}
