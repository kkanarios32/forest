#!/usr/bin/python3

import sys
from collections import defaultdict
import json
from rich import print
from rich.markup import escape
import subprocess


def run_command(cmd):
    result = subprocess.run(
        cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
    )
    if result.returncode != 0:
        raise RuntimeError(f"Command {' '.join(cmd)} failed:\n{result.stderr}")
    return result.stdout


def prettified_text(text, submatches):
    curr_idx = 0
    cut_text = []
    for match in submatches:
        start, end = match
        unmatched_text = escape(text[curr_idx:start])
        cut_text.append(unmatched_text)
        matched_word = escape(text[start:end])
        cut_text.append(f"[green]{matched_word}[/green]")
        curr_idx = end
    cut_text.append(text[curr_idx:])
    s = "".join(cut_text)
    s = s.lstrip().rstrip("\n")
    return s


def main(user_query):
    forester_output = run_command(["forester", "query", "all"])
    data = json.loads(forester_output)
    path_to_title = {}
    for entry in data:
        path = entry["sourcePath"].split("/")[-1]  # e.g. "008A.tree"
        uri = entry["uri"]  # e.g. "008A"
        title = entry["title"]  # e.g. "Flow Matching For Generative Modeling"
        path_to_title[path] = (title, uri)  # fallback to uri if title is missing

    rg_output = run_command(
        [
            "rg",
            "-S",
            "--json",
            user_query,
            "--iglob",
            "!trees/refs",
            "trees/",
        ]
    )

    lineno_text = defaultdict(list)
    submatches_dict = defaultdict(list)
    for line in rg_output.splitlines():
        if not line.strip():
            continue
        event = json.loads(line)
        if event["type"] == "match":
            path = event["data"]["path"]["text"].split("/")[-1]
            lineno = event["data"]["line_number"]
            text = event["data"]["lines"]["text"]
            submatches = event["data"]["submatches"]
            for match in submatches:
                submatches_dict[(lineno, path)].append((match["start"], match["end"]))
            lineno_text[path].append((lineno, text))

    for key, lines in lineno_text.items():
        title, uri = path_to_title[key]
        title = escape(title)
        print(f"[magenta]{title}[/magenta]([yellow]{uri}[/yellow]):")
        for line in lines:
            lineno, text = line
            pretty_text = prettified_text(text, submatches_dict[(lineno, key)])
            print(f"[red]{lineno}[/red]: {pretty_text}")
        print()


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python yourscript.py <query>")
        sys.exit(1)
    query = " ".join(sys.argv[1:])
    main(query)
